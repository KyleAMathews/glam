import parseCSS from './parseCSS'

import * as babylon from 'babylon'
import touch from 'touch'
import fs from 'fs'

import hashArray from './hash'

function getName(str){
  let regex = /name\s*:\s*([A-Za-z0-9\-_]+)\s*/gm
  let match = regex.exec(str)
  if(match){
    return match[1]
  }
}

function parser(path) {
  let code = path.hub.file.code
  let strs = path.node.quasi.quasis.map(x => x.value.cooked)
  let hash = hashArray([...strs]) // todo - add current filename? 
  let name = getName(strs.join('xxx')) || 'css'  

  let stubs = path.node.quasi.expressions.map(x => code.substring(x.start, x.end))          
  let ctr = 0

  let src = strs.reduce((arr, str, i) => {
    arr.push(str)
    if(i !== stubs.length) {
      arr.push(`var(--${name}-${hash}-${i})`)
    }
    return arr
  }, []).join('').trim()
  let rules = parseCSS(`.${name}-${hash} { ${src} }`)
  let parsed = rules.join('\n')

  return { hash, parsed, stubs, name }
}

function inline(path){
  let code = path.hub.file.code
  let strs = path.node.quasi.quasis.map(x => x.value.cooked)
  let hash = hashArray([...strs]) // todo - add current filename? 
  let name = getName(strs.join('xxx')) || 'css'  

  let stubs = path.node.quasi.expressions.map(x => code.substring(x.start, x.end))          
  let ctr = 0

  let src = strs.reduce((arr, str, i) => {
    arr.push(str)
    if(i !== stubs.length) {
      arr.push(`var(--${name}-${hash}-${i})`)
    }
    return arr
  }, []).join('').trim()

  let rules = parseCSS(`.${name}-${hash} { ${src} }`)
  rules = rules.map(rule => rule.replace(/var\(--[A-Za-z0-9-_]+-([0-9]+)\)/gm, (match, p1) => `$\{x${p1}}` ))
  

  let parsed = `(${stubs.map((x, i) => `x${i}`).join(', ')}) => [${rules.map(x => '`' + x + '`').join(',\n')}]`
  return { hash, parsed, stubs, name }  
}

module.exports = function({ types: t }){
  return {
    visitor: {
      Program: {
        enter(path, state){
          state.injected = false
          let inserted = {}
          state.toInsert = []
          let file = path.hub.file.opts.filename
          state.inject = function(){
            if(!state.injected){
              state.injected = true
              
              state.toInsert.push('/* do not edit this file */')
              
              let src = (state.opts.sync && !state.opts.inline) ? 
                `import './${require('path').basename(file) + '.css'}';` : 
                `import('./${require('path').basename(file) + '.css'}');`
              if(!state.opts.inline){
                let impNode = babylon.parse(src, {sourceType: 'module', plugins: ['*']}).program.body[0]
                path.node.body.unshift(impNode)
              }
              
            }          
          }
          state.insert = function(hash, css){
            if(!inserted[hash]){
              inserted[hash] = true 
              state.toInsert.push(css)
            }
          }
        },
        exit(path, state){
          let file = path.hub.file.opts.filename

          let toWrite = state.toInsert.join('\n').trim()
          if(!state.opts.inline && state.injected && fs.readFileSync(file + '.css', 'utf8') !== toWrite){
            if(!fs.existsSync(file + '.css')) {
              touch.sync(file + '.css')
            }

            fs.writeFileSync(file + '.css', toWrite)  
          }          
        } 
      },
      TaggedTemplateExpression(path, state){
        let { tag } = path.node            
        let code = path.hub.file.code

        if(tag.name === 'css') {
          
          state.inject()
          
          
          let newSrc 

          if(state.opts.inline){
            let { hash, parsed, stubs, name } = inline(path) 
            let cls = `'${name}-${hash}'`
            let vars = `[${stubs.join(', ')}]`
            newSrc = `css(${cls}, ${vars}, ${parsed})`

          }
          else {
            let { hash, parsed, stubs, name } = parser(path)
            state.insert(hash, parsed)  
            let cls = `'${name}-${hash}'`
            let vars = `[${stubs.join(', ')}]`
            newSrc = stubs.length > 0 ? `css(${cls}, ${vars})` : `css(${cls})`
          }
          
          path.replaceWith(babylon.parse(newSrc, {plugins: ['*']}).program.body[0].expression)
          
        }
      }
    }
  }
}